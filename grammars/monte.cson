'fileTypes': [
  'mt'
]
'name': 'Monte'
'patterns': [
  # Comments.
  {
    'match': '#.*$'
    'name': 'comment.line.octothorpe.monte'
  }
  {
    'match': '\\b(exports|import)\\b'
    'name': 'keyword.import.monte'
  }
  {
    'match': '\\b(via)\\b'
    'name': 'keyword.pattern.monte'
  }
  {
    'match': '\\b(if|else|match|switch)\\b'
    'name': 'keyword.control.flow.conditional.monte'
  }
  {
    'match': '\\b(for|while)\\b'
    'name': 'keyword.control.flow.loop.monte'
  }
  {
    'match': '\\b(try|catch|escape|finally)\\b'
    'name': 'keyword.control.flow.exception.monte'
  }
  {
    'match': '\\b(return|break|continue|exit)\\b'
    'name': 'keyword.control.flow.ejectors.monte'
  }
  {
    'match': '\\b(when)\\b'
    'name': 'keyword.control.flow.async.monte'
  }
  {
    'match': '\\b(in|pass)\\b'
    'name': 'keyword.other.monte'
  }
  {
    'match': '\\b(as|extends|guards|implements)\\b'
    'name': 'storage.modifier.monte'
  }
  {
    'match': '\\b(method|to)\\b'
    'name': 'storage.type.function.monte'
  }
  {
    'match': '\\b(fn|interface|object)\\b'
    'name': 'storage.type.object.monte'
  }
  {
    'match': '\\b(def)\\b'
    'name': 'storage.type.immutable.monte'
  }
  {
    'match': '\\b(var)\\b'
    'name': 'storage.type.mutable.monte'
  }
  # Guards. All guards have name storage.type.guard, since they are part of the
  # type system.
  {
    'match': '\\b(Any|Bool|Bytes|Char|Double|Int|Str|Void)\\b'
    'name': 'storage.type.guard.monte'
  }
  {
    'match': '\\b(List|Map|NullOk|Pair|Same|Set|Vow)\\b'
    'name': 'storage.type.guard.generic.monte'
  }
  {
    'match': '\\b(DeepFrozen|Selfless|SubrangeGuard|Transparent)\\b'
    'name': 'storage.type.guard.auditor.monte'
  }
  # Identifiers.
  {
    'match': '::"[^"]+"'
    'name': 'variable.other.monte'
  }
  # Literal exprs.
  {
    'comment': 'Literal constants'
    'match': '\\b(true|false|null)\\b'
    'name': 'constant.language.monte'
  }
  {
    'comment': 'Literal numeric constants'
    'match': '\\b(NaN|Infinity)\\b'
    'name': 'constant.numeric.monte'
  }
  {
    'comment': 'Literal floats'
    # XXX this regex is missing 1e10
    'match': '\\b([0-9]+\\.([0-9]+)?)|(([0-9]+)\\.[0-9]+)\\b'
    'name': 'constant.numeric.float.monte'
  }
  {
    'comment': 'Literal ints'
    'match': '\\b([0-9]+|0x[0-9a-fA-F]+)\\b'
    'name': 'constant.numeric.integer.monte'
  }
  {
    'begin': '"'
    'end': '"'
    'comment': 'Literal double quoted strings'
    'name': 'string.quoted.double.monte'
    'patterns': [
      {
        # \b \f \n \r \t \" \' \\ \x.. \u.... \U........
        'match': '\\\\([bfnrt"\'\\\\]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})'
        'name': 'constant.character.escape.monte'
      }
    ]
  }
  {
    # \b \f \n \r \t \" \' \\ \x.. \u.... \U........
    'match': '\'\\\\([bfnrt"\'\\\\]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})\''
    'comment': 'Literal single quoted escaped characters'
    'name': 'constant.character.escape.monte'
  }
  {
    'match': '\'.\''
    'comment': 'Literal single quoted strings'
    'name': 'string.quoted.single.monte'
  }
  # Quasiliterals.
  {
    'begin': '`'
    'end': '`'
    'name': 'string.quoted.interpolated.monte'
    'patterns': [
      {
        # \b \f \n \r \t \" \' \\ \x.. \u.... \U........
        'match': '\\$\\\\([bfnrt"\'\\\\]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})'
        'name': 'constant.character.escape.monte'
      }
      {
        'match': '[$@]\\w+'
        'name': 'variable.other.monte'
      }
      {
        # XXX doesn't work right
        'begin': '[$@]\\{'
        'end': '\\}'
        'name': 'variable.other.monte'
        'patterns': {
          'include': 'source.monte'
        }
      }
    ]
  }
  # Operators.
  {
    # ** * // / % + - << >> ..! ..
    'match': '\\*\\*|\\*|//|/|%|\\+|\\-|<<|>>|\\.\\.!|\\.\\.'
    'name': 'keyword.operator.arithmetic.monte'
  }
  {
    # .. ..!
    'match': '\\.\\.!?'
    'name': 'keyword.operator.range.monte'
  }
  {
    'match': '<=>|>=|<=|>|<'
    'name': 'keyword.operator.comparison.monte'
  }
  {
    'match': '==|!='
    'name': 'keyword.operator.equality.monte'
  }
  {
    'match': '\\?'
    'name': 'keyword.operator.pattern.monte'
  }
  {
    'match': '=~|!~'
    'name': 'keyword.operator.match-bind.monte'
  }
  {
    # && || &!
    'match': '&&|\\|\\||&!'
    'name': 'keyword.operator.logical.monte'
  }
  {
    # ^ & |
    'match': '\\^|&|\\|'
    'name': 'keyword.operator.bitwise.monte'
  }
  {
    'match': ':='
    'name': 'keyword.operator.assignment.monte'
  }
  {
    # **= *= //= /= %= += -= <<= >>= &&= &!= &= ||= |= ^=
    'match': '(\\*\\*|\\*|//|/|%|\\+|\\-|<<|>>|&&|&!|&|\\|\\||\\||^)='
    'name': 'keyword.operator.assignment.augmented'
  }
  {
    'match': ' =[^~=>]'
    'name': 'illegal.invalid.bad-assignment.monte'
  }
  # Safe scope.
  {
    'match': 'trace(ln)?'
    'name': 'support.function.python'
  }
  # Magic names.
  {
    'match': '\\b(meta|super)\\b'
    'name': 'variable.language.monte'
  }
]
'scopeName': 'source.monte'

'unused': [
  {
    'begin': '\\b(def)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\('
    'beginCaptures':
      '1':
        'name': 'storage.type.function.monte'
      '2':
        'name': 'entity.name.function.monte'
    'end': '\\)\\s*:|\\{'
  }
  {
    'begin': '\\b(to)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\('
    'beginCaptures':
      '1':
        'name': 'storage.type.method.monte storage.type.function.monte'
      '2':
        'name': 'entity.name.method.monte entity.name.function.monte'
    'end': '\\)\\s*:'
  }
]
